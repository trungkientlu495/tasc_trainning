1, Trong 1 câu query thứ tự thực hiện của các thành phần như thế nào
FROM
ON
JOIN
WHERE
GROUP BY
HAVING
SELECT
ORDER BY
LIMIT/OFFSET
2, Tìm hiểu và lấy ví dụ về
* Các loại JOIN (INNER JOIN,LEFT JOIN , RIGHT RIGHT,FULL OUTER JOIN)
- INNER JOIN: lấy dữ liệu của 2 bảng thỏa mãn điều kiện on
ví dụ select * from film x inner join film_actor y on x.film_id = y.film_id
- LEFT JOIN: lấy toàn bộ dữ liệu của bảng bên trái , còn bảng bên phải nếu không thoả
mãn điều kiện on thì nó trả về null
- RIGHT JOIN: lấy toàn bộ dữ liệu của bảng bên phải , còn bảng bên trái nêu không thỏa mãn
điều kiện on thì nó trả về null
- FULL OUTER JOIN: lấy toàn bộ dữ liệu của cả 2 bảng , nếu dữ liệu của 2 bảng
không thỏa mãn điều kiện on thì nó trả về null
- CROSS JOIN: không có điều kiện on , cross join dùng để nối các row của bảng A cho lần lượt các row 
của bảng B
* Sub Query
- Subquery trong WHERE
+ Dùng để lọc dữ liệu dựa trên kết quả của subquery , nó thường dùng với in , not in , exists
, = , < , >  <= , >=
ví dụ: 
SELECT name
FROM Students
WHERE id IN (
    SELECT student_id
    FROM Enrollments
    WHERE subject = 'Math'
);
- Subquery trong SELECT
+ Dùng để tính toán cho giá trị mỗi hàng
+ Kết quả của subquery trả về 1 giá trị duy nhất
ví dụ
SELECT name,
       (SELECT COUNT(*)
        FROM Enrollments e
        WHERE e.student_id = s.id) AS subject_count
FROM Students s;
- Subquery trong FROM 
+ Truy vấn con đóng vai trò như bảng tạm thời.
+ Dùng khi cần nhóm hoặc tính toán trung gian.
ví dụ:
SELECT avg_count.avg
FROM (
    SELECT student_id, COUNT(*) AS avg
    FROM Enrollments
    GROUP BY student_id
) AS avg_count;
- Subquery trong having
+ Dùng để lọc nhóm sau khi đã group by
ví dụ:
SELECT student_id, COUNT(*) AS subjects
FROM Enrollments
GROUP BY student_id
HAVING COUNT(*) > (
    SELECT AVG(subject_count)
    FROM (
        SELECT COUNT(*) AS subject_count
        FROM Enrollments
        GROUP BY student_id
    ) AS t
);
* CTE (Common Table Expression):
- Định nghĩa 
+ CTE (Common Table Expression) là một biểu thức bảng tạm thời, được định nghĩa trong 1 câu SQL bằng từ khóa WITH.
+ Nó giống như một “bảng ảo” mà bạn có thể sử dụng ngay trong query chính.
+ Khác với VIEW, CTE chỉ tồn tại trong phạm vi query hiện tại.
- Các loại CTE
a, CTE không đệ quy 
- Giống subquery nhưng viết dễ đọc hơn.
- Dùng để gom nhóm, tính toán trung gian rồi dùng lại trong query chính.
ví dụ: 
WITH SubjectCount AS (
    SELECT student_id, COUNT(*) AS subject_count
    FROM Enrollments
    GROUP BY student_id
)
SELECT AVG(subject_count) AS avg_subjects_per_student
FROM SubjectCount;
b, CTE đệ quy 
Dùng khi dữ liệu có tính chất cây (hierarchy): ví dụ nhân viên – quản lý, thư mục cha – con.
CTE đệ quy gồm 2 phần:
Anchor member: câu query cơ bản (điểm bắt đầu).
Recursive member: câu query gọi lại chính nó.
ví dụ: 
WITH RECURSIVE EmployeeHierarchy AS (
    -- Anchor: chọn ông sếp gốc (CEO)
    SELECT id, name, manager_id, 1 AS level
    FROM Employees
    WHERE manager_id IS NULL

    UNION ALL

    -- Recursive: tìm nhân viên dưới quyền
    SELECT e.id, e.name, e.manager_id, eh.level + 1
    FROM Employees e
    INNER JOIN EmployeeHierarchy eh ON e.manager_id = eh.id
)
SELECT *
FROM EmployeeHierarchy
ORDER BY level;
- Ứng dụng của CTE
Thay thế subquery → Query dễ đọc hơn.
Phân tích dữ liệu nhiều tầng → Có thể viết nhiều bước xử lý tuần tự.
Xử lý dữ liệu cây/phân cấp → Dùng CTE đệ quy.
Tái sử dụng logic phức tạp → Giúp tránh lặp lại query.
* RANKING 
- Định nghĩa: là các window function giúp bạn gán các thứ tự cho các bản ghi theo một tiêu chí sắp xếp nào đó
- Các hàm ranking phổ biến là: ROW_NUMBER(),RANK(),DENSE_RANK()
- Các loại ranking functions
+ ROW_NUMBER(): GÁN SỐ THỨ TỰ CHO CÁC BẢN GHI , NẾU DB CÓ CÁC BẢN GHI TRÙNG NHAU THÌ VẪN ĐÁNH SỐ THỨ TỰ LIÊN TIẾP
+ RANK(): GÁN SỐ THỨ TỰ CHO CÁC BẢN GHI , NẾU CÁC BẢN GHI TRÙNG GIÁ TRỊ THÌ TRÙNG RANK VÀ CÁC BẢN GHI SAU SẼ BỊ CHẬM SỐ LẦN BẢN
GHI TRÙNG VÍ DỤ CÓ 2 BẢN GHI TRÙNG VỊ TRÍ 2 BẢN GHI LÀ 2 THÌ BẢN GHI KẾ TIẾP CÓ VI TRÍ LÀ 4
+ DENSE_RANK(): GIỐNG RANK() NHƯNG KHÔNG NHẢY SỐ Ở BẢN GHI KẾ TIẾP
* View
- VIEW là một bảng ảo được tạo ra từ một câu lệnh SELECT.
- VIEW không lưu dữ liệu riêng (trừ materialized view trong một số DB như Oracle, PostgreSQL), mà dữ liệu luôn được lấy từ bảng gốc.
- Có thể coi VIEW như một query được đặt tên, giúp tái sử dụng và đơn giản hóa các câu lệnh phức tạp.
cú pháp view: 
CREATE VIEW view_name AS
SELECT ...
FROM ...
WHERE ...;
xem dữ liệu trong view: 
select * from view_name
a, Ưu điểm của view 
Đơn giản hóa query: Gom các câu lệnh phức tạp thành 1 view dễ gọi.
Tái sử dụng: Viết một lần, dùng nhiều lần
Bảo mật: Hạn chế quyền truy cập trực tiếp bảng gốc (cho user chỉ query được view).
Tách biệt logic: Nếu cấu trúc bảng gốc thay đổi, có thể điều chỉnh trong view mà không cần sửa tất cả query.
b, CRUD trên view
- Có thể update,insert,delete nếu trong view chỉ có 1 table nếu có 2 table thì se không được